# 4.合并两个排序的链表

 [合并两个排序的链表](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=295&tqId=23267&ru=%2Fpractice%2F345e2ed5f81d4017bbb8cc6055b0b711&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj )



#### 递归：

```c++
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        // 一个为空 返回另外一个
        if(pHead1 == NULL) return pHead2;
        if(pHead2 == NULL) return pHead1;
        
        // 递归排序后续
        if(pHead1->val < pHead2->val){
            pHead1->next = Merge(pHead1->next, pHead2);
            return pHead1;
        }else{
            pHead2->next = Merge(pHead1, pHead2->next);
            return pHead2;
        }
    }
};
```



#### 迭代：

```c++
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        ListNode* dummy = new ListNode(0);
        ListNode* tail = dummy;
        // 两两比较 取较小值的节点 并 添加到 tail 后面
        while(pHead1 && pHead2){
            if(pHead1->val < pHead2->val){
                tail->next = pHead1;
                pHead1 = pHead1->next;
            }else{
                tail->next = pHead2;
                pHead2 = pHead2->next;
            }
            tail = tail->next;
        }
        // 如果还有剩余 添加到tail后面
        tail->next = pHead1 ? pHead1 : pHead2;    
        return dummy->next;
    }
};
```

