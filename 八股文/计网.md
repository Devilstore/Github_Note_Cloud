# 计算机网络

#### **1.  select、 poll、 epoll**

- select，poll，[epoll](https://so.csdn.net/so/search?q=epoll&spm=1001.2101.3001.7020) 都是 IO 多路复用的机制。IO 多路复用的本质是通过一种机制，让单个进程可以监视多个描述符，当发现某个描述符就绪之后，能够通知程序进行相应的读写操作。
- select，poll，epoll 都是同步 IO。所谓同步 IO，便是读写是阻塞的，需要在读写事件就绪后自己负责读写，而异步 IO 会把数据从内核拷贝到用户空间，并不需要自己负责读写。
- select、poll 和 epoll 都是 Linux 提供的 IO 复用方式。

##### **select：**

- select 实现多路复用的方式是，将已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝**到内核空间，让内核来轮询遍历检查是否有网络事件产生，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理。
- select 这种方式，需要进行 **2 次「遍历」文件描述符集合**，一次是在内核态里，一个次是在用户态里 ，而且还会发生 **2 次「拷贝」文件描述符集合**，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。
- select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

##### poll

- poll改变了**文件描述符集合**的描述方式，使用了**pollfd**结构而不是select的**fd_set**结构，使得poll支持的**文件描述符集合**限制远大于select的1024。poll虽然解决了**文件描述符集合**大小1024的限制问题，从实现来看。很明显它并没优化大量**文件描述符集合**被整体复制于用户态和内核态的地址空间之间，以及个别**文件描述符**就绪触发整体**文件描述符集合**的遍历的低效问题。
- poll 和 select 并没有太大的本质区别，**都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合**，这种方式随着并发数上来，性能的损耗会呈指数级增长。

**很明显发现，select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。**

##### epoll

epoll 通过两个方面，很好解决了 select/poll 的问题。

- *第一点*，epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，把需要监控的 socket 通过 `epoll_ctl()` 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 `O(logn)`。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。
- *第二点*， epoll 使用**事件驱动**的机制，内核里**维护了一个 rdlist 链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中，当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。
- epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，**epoll 被称为解决 C10K 问题的利器**。

##### 区别：

![image-20220807190856244](https://devil-picture-bed.oss-cn-shenzhen.aliyuncs.com/image/202208071908406.png)



#### 2. ET 模式和LT 模式

epoll 支持两种事件触发模式，分别是**边缘触发（edge-triggered，ET）水平触发（level-triggered，LT）**。

- 使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；
- 使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**，目的是告诉我们有数据需要读取；

水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。

select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。

#### 3. TCP 三次握手过程，有什么状态，状态机如何变化？

- 三次握手状态变化示意图

![image-20220807204318486](https://devil-picture-bed.oss-cn-shenzhen.aliyuncs.com/image/202208072043572.png)

客户端做为连接发起方：

- 初始状态：客户端为 **CLOSED** 状态，服务端为 **LISTEN** 状态
- 第一次握手：客户端发送 **SYN报文**，将 seq 置为 **x**，此时客户端状态转为 **SYN_SENT**
- 第二次握手：服务端收到**SYN报文**，返回 **SYN + ACK 报文**，将seq置为**y**，ack为**x + 1**，此时服务器状态转为**SYN_RCVD**
- 第三次握手：客户端收到 **SYN + ACK 报文**，此时客户端已经知道双方的收发都没有问题，但为了让服务端也知道故返回**ACK报文**，ack置为y+1，此事后客户端状态为**ESTABLISHED，并可以发送数据**
- 最后：服务端 收到 **ACK报文**，此时服务端已经知道双方的收发都没有问题，此时服务端状态为 **ESTABLISHED**。

#### 4. TCP三次握手的目的：

- 确认双方的具有数据收发能力，初始化序列号，确认窗口大小并建立 TCP 连接。

- **为了防止旧的重复连接初始化造成混乱**（主要原因）

  - 如果一个旧的SYN报文比新的SYN报文早到达服务端，此时服务端就会回一个SYN+ACK给客户端，客户端收到后，根据上下文，判断这是一个历史连接（序列号过期或者超时），那么客户端就会发送RST给服务端，表示中止这一次连接。

- 同步双方的初始序列号

- 避免资源浪费：

  - 如果只有两次握手，服务器端不知道客户端是否收到自己的ACK报文，那么每次遇到SYN报文就会只能先主动建立一个连接，如果客户端的 `SYN` 阻塞了，重复发送多次 `SYN` 报文，那么服务器在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。** 

  

  不使用「两次握手」和「四次握手」的原因：

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

#### 5. TCP四次挥手？

四次挥手状态变换示意图：

![image-20220807204958061](https://devil-picture-bed.oss-cn-shenzhen.aliyuncs.com/image/202208072049112.png)

**客户端做为发起方：**

- 客户端打算关闭连接，此时会发送一个 TCP 首部 **FIN** 标志位被置为 `1` 的报文，也即 **FIN** 报文，之后客户端进入 **FIN_WAIT_1** 状态。
- 服务端收到该报文后，就向客户端发送 **ACK** 应答报文，接着服务端进入 **CLOSED_WAIT**状态。
- 客户端收到服务端的  **ACK** 应答报文后，之后进入 **FIN_WAIT_2** 状态。
- 等待服务端处理完数据后，也向客户端发送 **FIN** 报文，之后服务端进入 **LAST_ACK **状态。
- 客户端收到服务端的 **FIN**报文后，回一个  **ACK**  应答报文，之后进入 **TIME_WAIT** 状态
- 服务器收到了 **ACK** 应答报文后，就进入了**CLOSED** 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 **2MSL** 的 **TIME_WAIT**  时间后，自动进入**CLOSED**状态，至此客户端也完成连接的关闭。

**为什么是四次挥手？**

- 关闭连接时，客户端向服务端发送**FIN** 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务器收到客户端的 **FIN** 报文时，先回一个 **ACK** 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 **FIN** 报文给客户端来表示同意现在关闭连接。



#### 5. 什么是 TIME_WAIT 状态，为什么需要 TIME_WAIT 状态？时间是多久，为什么？



- 四次挥手，发起端收到对端的**FIN报文**之后返回**ACK报文**之后的状态。
- TIME_WAIT状态可以防止ACK报文丢失问题。
- TIME_WAIT的长度为2*MSL，这样ACK丢失之后，FIN会再次发送，在这段时间里发起端还可以收到FIN报文。
- 防止上一个TCP连接的延迟的数据包，被接收后，影响到新的TCP连接



#### 6. TCP和UDP的区别：

![image-20220807205252731](https://devil-picture-bed.oss-cn-shenzhen.aliyuncs.com/image/202208072052763.png)

- 连接：TCP 是面向连接的传输层协议，传输数据前先要建立连接。UDP 是不需要连接，即刻传输数据。
- 服务对象：TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信
- 可靠性：TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。UDP 是尽最大努力交付，不保证可靠交付数据。
- 拥塞控制、流量控制：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络拥堵也不影响 UDP 的发送速率。
- 首部开销：TCP 首部长度较长，最少20字节，最多40字节。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
- 传输方式：TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
- 分片不同：TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片
- 应用场景不同：
  - TCP：由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：
    - `FTP` 文件传输；
    - HTTP / HTTPS；
  - 由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：
    - 包总量较少的通信，如 `DNS` 、`SNMP` 等；
    - 视频、音频等多媒体通信；
    - 广播通信；



#### 7. TCP拥塞控制？ 慢启动的时候窗口在什么情况下会增长？会什么会呈指数增长？

TCP拥塞控制由三部分组成：

- 慢启动：每次收到一个ACK报文，会将拥塞窗口（cwnd）加一个MSS，从1开始成指数增长
- 拥塞避免：当cwnd $\geq$ 慢启动阈值（sstresh）时，窗口呈线性增长，当收到三个连续的冗余ACK之后，进入快重启阶段
  - 发生超时重传（网络拥堵）： ssthresh = cwnd / 2， cwnd = 1；      进入慢启动
  - 发生快速重传（网络拥堵）： ssthresh = cwnd / 2,    cwnd /= 2;       进入快速恢复
- 快速恢复：发生重传之后，ssthresh 和 cwnd 已经更新
  - 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
  - 重传丢失的数据包；
  - 如果再收到重复的 ACK，那么 cwnd 增加 1；
  - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
- 快速恢复算法的变化过程如下图：

![image-20220807214249541](https://devil-picture-bed.oss-cn-shenzhen.aliyuncs.com/image/202208072142611.png)





















